# Data Model: Telegram Channel URL Monitor with yt-dlp Integration

**Feature**: 001-build-an-app  
**Date**: 2025-10-04  
**Phase**: 1 - Design & Contracts

---

## Entity Relationship Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ProcessedMessage    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MessageId (PK)      â”‚
â”‚ ChannelId           â”‚
â”‚ ProcessedAt         â”‚
â”‚ UrlCount            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 1:N
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DownloadJob         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ JobId (PK)          â”‚
â”‚ MessageId (FK)      â”‚
â”‚ Url                 â”‚
â”‚ Status              â”‚
â”‚ CreatedAt           â”‚
â”‚ CompletedAt?        â”‚
â”‚ ErrorMessage?       â”‚
â”‚ OutputPath?         â”‚
â”‚ RetryCount          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AppState            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Key (PK)            â”‚
â”‚ Value               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Entity Definitions

### ProcessedMessage

Tracks Telegram messages that have been seen and processed for URLs.

**Purpose**: Prevent duplicate processing after restarts. Provides audit trail of which messages were handled.

**Fields**:
- `MessageId` (long, PK): Telegram message unique identifier
- `ChannelId` (long, NOT NULL): Source channel ID
- `ProcessedAt` (DateTime, NOT NULL): UTC timestamp when message was first seen
- `UrlCount` (int, NOT NULL): Number of URLs extracted from this message

**Indexes**:
- PRIMARY KEY on MessageId (auto-indexed)
- Consider adding index on ChannelId if multi-channel support added later

**Constraints**:
- MessageId must be unique
- ChannelId must match configured channel (application-level validation)

**Lifecycle**:
- Created: When message is first received and URLs extracted
- Updated: Never (immutable record)
- Deleted: Manual cleanup for old messages (retention policy TBD)

---

### DownloadJob

Represents a single URL download task from a Telegram message.

**Purpose**: Queue management, retry tracking, status reporting, output file location.

**Fields**:
- `JobId` (Guid, PK): Unique job identifier (generated by app)
- `MessageId` (long, FK â†’ ProcessedMessage, NOT NULL): Reference to source message
- `Url` (string, NOT NULL): Target URL to download
- `Status` (enum string, NOT NULL): Current job state
  - Values: `Queued`, `InProgress`, `Completed`, `Failed`
  - CHECK constraint enforces valid values
- `CreatedAt` (DateTime, NOT NULL): UTC timestamp when job was queued
- `CompletedAt` (DateTime?, NULLABLE): UTC timestamp when job finished (success or failure)
- `ErrorMessage` (string?, NULLABLE): Error details if Status = Failed
- `OutputPath` (string?, NULLABLE): Filesystem path to downloaded file if Status = Completed
- `RetryCount` (int, NOT NULL, DEFAULT 0): Number of retry attempts (max 3)

**Indexes**:
- PRIMARY KEY on JobId (auto-indexed)
- INDEX on Status for queue queries (`WHERE Status = 'Queued'`)
- INDEX on CreatedAt for chronological ordering

**Constraints**:
- Status must be one of: Queued, InProgress, Completed, Failed
- CompletedAt must be NULL if Status = Queued or InProgress
- OutputPath must be NULL if Status â‰  Completed
- RetryCount must be â‰¤ 3

**Lifecycle**:
- Created: When URL is extracted from message (Status = Queued)
- Updated: Status transitions (Queued â†’ InProgress â†’ Completed/Failed)
- Deleted: Manual cleanup for old completed jobs (retention policy TBD)

**State Machine**:
```
  Queued
    â†“
InProgress â†â”€â” (retry)
    â†“        â”‚
Completed / Failed
```

---

### AppState

Key-value store for application-level state and metadata.

**Purpose**: Persist last processed message offset, configuration version, maintenance flags.

**Fields**:
- `Key` (string, PK): State identifier
- `Value` (string, NOT NULL): State value (JSON-serialized if complex)

**Known Keys**:
- `LastMessageId` (long): Most recent Telegram message ID processed
- `ConfigVersion` (string): Version of config schema (for migration detection)
- `MaintenanceMode` (bool): Flag to pause processing during maintenance

**Indexes**:
- PRIMARY KEY on Key (auto-indexed)

**Constraints**:
- Key must be unique
- Value format depends on Key (application-level validation)

**Lifecycle**:
- Created: On first app startup (bootstrap values)
- Updated: Frequently (LastMessageId after each message batch)
- Deleted: Rarely (only for deprecated keys during migrations)

---

## C# Domain Models

### Message (In-Memory Model)

Represents a Telegram message received from the monitored channel.

```csharp
public class Message
{
    public long MessageId { get; init; }
    public long ChannelId { get; init; }
    public string Text { get; init; } = string.Empty;
    public DateTime Timestamp { get; init; }
    public List<string> ExtractedUrls { get; init; } = new();
    public ProcessingState State { get; set; }
}

public enum ProcessingState
{
    Seen,
    Processing,
    Complete,
    Error
}
```

**Notes**:
- Not persisted directly (mapped to ProcessedMessage + DownloadJobs)
- Init-only properties ensure immutability after creation
- ExtractedUrls populated by UrlExtractor service
- State tracked for emoji reaction logic

---

### DownloadJob (Database Entity)

```csharp
public class DownloadJob
{
    public Guid JobId { get; init; } = Guid.NewGuid();
    public long MessageId { get; init; }
    public string Url { get; init; } = string.Empty;
    public JobStatus Status { get; set; } = JobStatus.Queued;
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;
    public DateTime? CompletedAt { get; set; }
    public string? ErrorMessage { get; set; }
    public string? OutputPath { get; set; }
    public int RetryCount { get; set; } = 0;
}

public enum JobStatus
{
    Queued,
    InProgress,
    Completed,
    Failed
}
```

**Mapping to SQLite**:
- JobId â†’ TEXT (Guid.ToString())
- Status â†’ TEXT (enum name)
- Timestamps â†’ TEXT (ISO 8601 format: `yyyy-MM-ddTHH:mm:ss.fffZ`)

---

### Configuration (Application Model)

```csharp
public class BotConfiguration
{
    public TelegramConfig Telegram { get; set; } = new();
    public YtDlpConfig YtDlp { get; set; } = new();
    public StorageConfig Storage { get; set; } = new();
    public EmojiConfig Emojis { get; set; } = new();
    public LoggingConfig Logging { get; set; } = new();
}

public class TelegramConfig
{
    [Required]
    public string BotToken { get; set; } = string.Empty;
    
    [Required]
    [Range(1, long.MaxValue)]
    public long ChannelId { get; set; }
    
    public int PollingIntervalSeconds { get; set; } = 2;
}

public class YtDlpConfig
{
    [Required]
    public YtDlpMode Mode { get; set; } = YtDlpMode.Local;
    
    public string ExecutablePath { get; set; } = "/usr/local/bin/yt-dlp";
    
    public string? RemoteApiUrl { get; set; }
    
    public string? RemoteApiKey { get; set; }
    
    public string Quality { get; set; } = "bestvideo+bestaudio/best";
    
    public string OutputTemplate { get; set; } = "%(uploader)s/%(upload_date)s/%(title)s.%(ext)s";
    
    public string? ConfigFilePath { get; set; }
    
    public int TimeoutMinutes { get; set; } = 60;
}

public enum YtDlpMode
{
    Local,
    Remote
}

public class StorageConfig
{
    [Required]
    public string DownloadPath { get; set; } = "/data/downloads";
    
    [Required]
    public string DatabasePath { get; set; } = "/data/state.db";
    
    public long MinimumFreeSpaceGB { get; set; } = 1;
}

public class EmojiConfig
{
    public string Seen { get; set; } = "ğŸ‘€";
    public string Processing { get; set; } = "âš™ï¸";
    public string Complete { get; set; } = "âœ…";
    public string Error { get; set; } = "âŒ";
    
    public void Validate()
    {
        var emojis = new[] { Seen, Processing, Complete, Error };
        if (emojis.Distinct().Count() != 4)
            throw new InvalidOperationException("Emojis must be unique");
    }
}

public class LoggingConfig
{
    public string MinimumLevel { get; set; } = "Information";
}
```

---

## SQLite Schema

```sql
-- Enable foreign keys and WAL mode for concurrency
PRAGMA foreign_keys = ON;
PRAGMA journal_mode = WAL;

-- Processed messages from Telegram
CREATE TABLE ProcessedMessages (
    MessageId INTEGER PRIMARY KEY,
    ChannelId INTEGER NOT NULL,
    ProcessedAt TEXT NOT NULL,
    UrlCount INTEGER NOT NULL DEFAULT 0
);

-- Download job queue
CREATE TABLE DownloadJobs (
    JobId TEXT PRIMARY KEY,
    MessageId INTEGER NOT NULL,
    Url TEXT NOT NULL,
    Status TEXT NOT NULL CHECK(Status IN ('Queued','InProgress','Completed','Failed')),
    CreatedAt TEXT NOT NULL,
    CompletedAt TEXT,
    ErrorMessage TEXT,
    OutputPath TEXT,
    RetryCount INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (MessageId) REFERENCES ProcessedMessages(MessageId)
);

CREATE INDEX idx_jobs_status ON DownloadJobs(Status);
CREATE INDEX idx_jobs_created ON DownloadJobs(CreatedAt);

-- Application state key-value store
CREATE TABLE AppState (
    Key TEXT PRIMARY KEY,
    Value TEXT NOT NULL
);

-- Bootstrap initial state
INSERT OR IGNORE INTO AppState (Key, Value) VALUES ('LastMessageId', '0');
INSERT OR IGNORE INTO AppState (Key, Value) VALUES ('ConfigVersion', '1');
```

---

## Data Access Patterns

### Query: Get Next Queued Job

```csharp
var nextJob = await connection.QueryFirstOrDefaultAsync<DownloadJob>(
    "SELECT * FROM DownloadJobs WHERE Status = 'Queued' ORDER BY CreatedAt LIMIT 1");
```

**Frequency**: Every queue poll cycle (sequential processing)  
**Index Used**: `idx_jobs_status`  
**Performance**: O(log n) lookup + O(1) retrieval

---

### Query: Check if Message Already Processed

```csharp
var exists = await connection.ExecuteScalarAsync<bool>(
    "SELECT EXISTS(SELECT 1 FROM ProcessedMessages WHERE MessageId = @MessageId)",
    new { MessageId = messageId });
```

**Frequency**: Every new message received  
**Index Used**: PRIMARY KEY (MessageId)  
**Performance**: O(log n) lookup

---

### Query: Update Job Status

```csharp
await connection.ExecuteAsync(@"
    UPDATE DownloadJobs 
    SET Status = @Status, CompletedAt = @CompletedAt, OutputPath = @OutputPath
    WHERE JobId = @JobId",
    new { JobId, Status, CompletedAt, OutputPath });
```

**Frequency**: On download start/completion  
**Index Used**: PRIMARY KEY (JobId)  
**Performance**: O(log n) lookup + O(1) update

---

### Query: Get Last Processed Message ID

```csharp
var lastMessageId = await connection.ExecuteScalarAsync<long>(
    "SELECT Value FROM AppState WHERE Key = 'LastMessageId'");
```

**Frequency**: On app startup  
**Index Used**: PRIMARY KEY (Key)  
**Performance**: O(1) lookup

---

## Data Migration Strategy

**Approach**: Manual SQL migration scripts (no ORM migrations for MVP)

**Rationale**:
- Only 3 tables, minimal complexity
- EF Core migrations overkill for this scale
- Direct SQL provides full control and transparency
- Version tracked in AppState table (ConfigVersion key)

**Migration Process**:
1. Check `ConfigVersion` in AppState on startup
2. If version < current: Apply migration SQL scripts sequentially
3. Update `ConfigVersion` after successful migration
4. Log migration actions for audit trail

**Future Migrations** (examples):
- v2: Add `Priority` column to DownloadJobs
- v3: Add indexes on CompletedAt for performance
- v4: Add `Tags` table for job categorization

---

## Validation Rules

### Application-Level Validation

**ProcessedMessage**:
- MessageId must be positive
- ChannelId must match configured channel
- UrlCount must be â‰¥ 0

**DownloadJob**:
- Url must be valid HTTP/HTTPS scheme
- Url length must be â‰¤ 2048 characters
- Status transitions must follow state machine rules
- RetryCount must be â‰¤ 3
- CompletedAt must be after CreatedAt (if not null)

**Configuration**:
- BotToken must not be empty/whitespace
- ChannelId must be non-zero
- Download and database paths must be absolute
- YtDlpMode must be Local or Remote
- If Remote mode: RemoteApiUrl must be valid HTTP/HTTPS URL
- MinimumFreeSpaceGB must be > 0
- Emojis must be unique (validated via EmojiConfig.Validate())

---

## Testing Strategy

### Unit Tests (Data Access Layer)

- **StateManager.SaveJob**: Verify job persisted with correct values
- **StateManager.GetNextQueuedJob**: Verify FIFO ordering
- **StateManager.UpdateJobStatus**: Verify status transitions and timestamps
- **StateManager.IsMessageProcessed**: Verify duplicate detection
- **StateManager.GetLastMessageId**: Verify state retrieval

### Integration Tests (SQLite)

- Use in-memory SQLite database (`:memory:`) for isolation
- Test foreign key constraints (delete message â†’ cascade behavior?)
- Test index usage via EXPLAIN QUERY PLAN
- Test concurrent access (multiple readers, single writer)
- Test database corruption recovery

### Contract Tests

- Verify DownloadJob serialization/deserialization
- Verify Configuration binding from JSON
- Verify enum string conversions (Status, YtDlpMode)

---

**Data Model Phase Complete** âœ…  
**Next**: Generate service contracts and API interfaces
